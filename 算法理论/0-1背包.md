<font size=4 face="楷体">

$HONG-LOU$ <t> </t> $2022-9-1$

<h3> 1.题目引入 </h3>

$\enspace \enspace$ 有 $n$ 件物品和一个容量为 $V$ 的背包,每件物品有各自的价值且只能被选择一次,要求在有限的背包容量下,装入的物品价值最大.

$\enspace \enspace$ 动态规划是不断决策求最优解的过程,$[0 - 1]$ 背包既是不断对第 $i$ 个物品做出决策,
$[0-1]$ 正好代表不选和选择两种状态.

### 2.二维 $dp$

$\enspace \enspace (1)$ 状态 $f[i][j]$ 定义: 前 $i$ 个物品,背包容量为 $j$ 时的最优解(最大价值): 
$\enspace \enspace \enspace$ 当前的状态依赖于之前的状态,可以理解为从初始状态 $f[0][0] = 0$ 开始决策,有 $N$ 件物品,则需要 $N$ 次决策,每一次对 $i$ 件物品的决策,状态 $f[i][j]$ 不断由之前的状态更新而来.

$\enspace \enspace (2)$ 当前背包容量不够($j < v[i]$),没得选,因此前 $i$ 个物品最优解即为前 $i - 1$ 个物品最优解: 
$\enspace \enspace \enspace$ 对应代码: $f[i][j] = f[i - 1][j]$.

$\enspace \enspace (3)$ 当前背包容量够,可以选,因此需要决策选与不选第 $i$ 个物品: 
$\enspace \enspace \enspace$ 选: $f[i][j] = f[i - 1][j - v[i]] + w[i]$.
$\enspace \enspace \enspace$ 不选: $f[i][j] = f[i - 1][j]$.
$\enspace \enspace \enspace$ 我们的决策时如何取到最大值,因此以上两种情况取 $max$.

``` c++
#include <bits/stdc++.h>

int main() {
  int n, m;
  std::cin >> n >> m;

  std::vector<int> v(n + 1), w(n + 1);

  for(int i = 1; i <= n; i++) {
    std::cin >> v[i] >> w[i];
  }

  std::vector<std::vector<int>> f(n + 1, std::vector<int>(m + 1, 0));

  for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= m; j++) {
      if(j < v[i]) {
        f[i][j] = f[i - 1][j];
      }
      else {
        f[i][j] = std::max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
      }
    }
  }
  
  std::cout << f[n][m] << "\n";
  return 0;
}
```

### 3.一维 $dp$

$\enspace \enspace$ 将状态 $f[i][j]$ 优化到一维 $f[j]$,实际上只需要做一个等价变换.

$\enspace \enspace$ 为什么可以这样变形呢 ? 我们定义的状态 $f[i][j]$ 可以求得任意合法的 $i$ 与 $j$ 最优解,但题目只需要求得最终状态 $f[n][m]$ 因此我们只需要一维得空间来更新状态.

$\enspace \enspace (1)$ 状态 $f[j]$ 得定义: $n$ 件物品,背包容量 $j$ 下的最优解.

$\enspace \enspace(2)$ 注意枚举背包容量 $j$ 必须从 $m$ 开始.

$\enspace \enspace(3)$ 为什么一维一维状况下枚举背包容量需要逆序?在二维情况下,状态 $f[i][j]$ 与 $f[i - 1][j]$ 是独立的.而优化到一维后,如果我们还是正序,则有 $f[$较小体积$]$ 更新到 $f[$较大体积$]$,则有可能本应该用第 $i - 1$ 轮的状态却用的是第 $i$ 轮的状态.

$\enspace \enspace(4)$ 例如,一维状态第 $i$ 轮对体积为 $3$ 的物品进行决策，则 $f[7]$ 由 $f[4]$ 更新而来，这里的 $f[4]$ 正确应该是 $f[i - 1][4]$，但从小到大枚举j这里的 $f[4]$ 在第 $i$ 轮计算却变成了 $f[i][4]$.当逆序枚举背包容量 $j$ 时，我们求 $f[7]$ 同样由 $f[4]$ 更新，但由于是逆序，这里的 $f[4]$ 还没有在第 $i$ 轮计算，所以此时实际计算的 $f[4]$ 仍然是 $f[i - 1][4]$.

$\enspace \enspace(5)$ 简单来说,一维情况正序更新 $f[j]$ 需要用到前面计算的状态已经被 **污染**,逆序则不会有这样的问题.

$\enspace \enspace$ 状态转移方程为: $f[j] = max(f[j], f[j - v[i]] + w[i]$.

``` c++
for(int i = 1; i <= n; i++) {
  for(int j = m; j >= 0; j--) {
    if(j < v[i]) {
      // f[i][j] = f[i - 1][j];
      f[j] = f[j];
    }
    else {
      // f[i][j] = std::max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
      f[j] = std::max(f[j], f[j - v[i]] + w[i]);
    }
  }
}
```
$\enspace \enspace$ 实际上,只有当枚举的背包容量大于等于 $v[i]$ 时才会更新状态,因此我们可以修改终止循环条件进一步进行优化.
```c++
for(int i = 1; i <= n; i++) {
  for(int j = m; j >= v[i]; j--) {
    f[j] = std::max(f[j], f[j - v[i]] + w[i]);
  }
}
```
$\enspace \enspace$ 关于状态 $f[j]$ 的补充说明
$\enspace \enspace \enspace$ 二维状态下的 $f[i][j]$ 是前 $i$ 件物品,背包容量 $j$ 下的最大价值.一维下,少了前 $i$ 件物品这个维度,代码中决策到第 $i$ 件物品(循环到$i$轮), $f[i]$ 就是前 $i$ 轮已经决策的物品且背包容量 $j$ 下的最大价值.
$\enspace \enspace \enspace$ 因此当执行完循环结构后,由于已经决策了所有物品,$f[j]$ 就是所有物品背包容量 $j$ 下的最大价值,即一维 $f[j]$ 等价于二维 $f[n][j]$.

### 4.输入优化
``` c++
#include <bits/stdc++.h>

int main() {
  int n, m;
  std::cin >> n >> m;

  std::vector<int> f(m + 1);

  for(int i = 1; i <= n; i++) {
    int v, w;
    std::cin >> v >> w;

    for(int j = m; j >= v; j--) {
      f[j] = std::max(f[j], f[j - v] + w);
    }
  }

  std::cout << f[m] << "\n";
  return 0;
}
```

### 完结撒花 $! \enspace !$

$\phi$