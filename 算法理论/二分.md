<font size=4 face="楷体">

### $\mathcal{BINARY~SEARCH ~~ ALGORITHM ~~~ BY ~~~ HONG-LOU} $

<br>
<br>
<br>


## $~~$二分战神传世圣经

#### $$\mathcal{Stop learning useless algorithms}$$ $$\mathcal{go and solve some problems}$$ $$\mathcal{learn how to use binary search}$$

<br>
<br>


### 定义

$~~~~$ 二分查找 $(binary - search)$, 也称折半搜索 $(half-interval search)$, 对数搜索 $(logarithmic search)$, 是用来在一个有序数组中查找某一元素的算法.

<br>
<br>

### 过程
$~~~~$ 以在一个升序数组中查找一个数为例。

$~~~~$ 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找.

<br>
<br>

### 时间复杂度
$~~~~$ 二分查找的最优时间复杂度是 $O(1)$.

$~~~~$ 二分查找的平均时间复杂度和最坏时间复杂度均为 $O(\log n)$. 因为在二分搜索的过程中, 算法每次都会把查询的区间减半, 所以对于一个长度为 $n$ 的数组, 至多会进行 $O(\log n)$ 次查找.

<br>
<br>

### 实现
``` c++
int binary_search(int start, int end, int key) {
  int ret = -1;  // 未搜索到数据返回-1下标
  int mid;
  while (start <= end) {
    mid = start + ((end - start) >> 1);  // 直接平均可能会溢出，所以用这个算法
    if (arr[mid] < key)
      start = mid + 1;
    else if (arr[mid] > key)
      end = mid - 1;
    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于
      ret = mid;
      break;
    }
  }
  return ret;  // 单一出口
}
```

<br>
<br>
<br>


### $STL$ 的二分查找

$\bullet$ $std::lower\_bound$ 查找首个不小于给定值的元素的函数.
$\bullet$ $std::upper\_bound$ 查找首个大于给定值的元素的函数.
