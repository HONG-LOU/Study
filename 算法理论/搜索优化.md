<font size=4 face="楷体"> 

$~~~~$ $Dfs$ 作为时间复杂度很高的算法, 用来骗骗分还行, 但毕竟不能用来作为正解.

$~~~~$ 既然不能作为正解, 那就多骗一点分(逃).

#### 深搜模板

``` c++
int ans = 最坏情况, now;  // now 为当前答案

void dfs(传入数值) {
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

### 剪枝方法:  ① 记忆化搜索 ② 最优性剪枝 ③ 可行性剪枝.

#### 记忆化搜索

$~~~~$ 因为记忆化搜索和 $dp$ 相关, 所以这里只给出模板, 后面再深入研究.

``` c++
int g[MAXN];  // 定义记忆化数组
int ans = 最坏情况, now;

void dfs f(传入数值) {
  if (g[规模] != 无效数值) return;  // 或记录解，视情况而定
  if (到达目的地) ans = 从当前解与已有解中选最优;  // 输出解，视情况而定
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}

int main() {
  // ...
  memset(g, 无效数值, sizeof(g));  // 初始化记忆化数组
  // ...
}
```

#### 最优性剪枝

$~~~~$ 在搜索中导致运行速度慢的原因还有一种, 就是在当前解已经比已有解差时任然在搜索, 那么我们只需要判断当前解是否已经差于已有解.

``` c++
int ans = 最坏情况, now;

void dfs(传入数值) {
  if (now比ans的答案还要差) return;
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

#### 可行性剪枝

$~~~~$ 在搜索过程中当前解已经不可用了还继续搜下去也是运行慢的原因.

``` c++
int ans = 最坏情况, now;

void dfs(传入数值) {
  if (当前解已不可用) return;
  if (到达目的地) ans = 从当前解与已有解中选最优;
  for (遍历所有可能性)
    if (可行) {
      进行操作;
      dfs(缩小规模);
      撤回操作;
    }
}
```

### 剪枝思路
$~~~~$ 剪枝思路有很多种，大多需要对于具体问题来分析，在此简要介绍几种常见的剪枝思路.

$~~~~ \bullet $ 极端法：考虑极端情况，如果最极端（最理想）的情况都无法满足，那么肯定实际情况搜出来的结果不会更优了.

$~~~~ \bullet $ 调整法：通过对子树的比较剪掉重复子树和明显不是最有“前途”的子树.

$~~~~ \bullet $ 数学方法：比如在图论中借助连通分量，数论中借助模方程的分析，借助不等式的放缩来估计下界等等.